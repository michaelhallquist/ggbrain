#' An R6 class for constructing a ggbrain plot from a ggbrain_slices object
#' @importFrom ggplot2 scale_fill_distiller
#' @importFrom purrr transpose
#' @export
ggbrain_plot <- R6::R6Class(
  classname="ggbrain_plot",
  private = list(
    pvt_slices = NULL,
    pvt_layers = NULL, # list of ggbrain_layer objects
    pvt_ggbrain_panels = NULL,
    pvt_nslices = NULL,

    # convert input to a valid ggbrain_layer object
    validate_layer = function(layer_def) {

    },

    set_default_scale = function(layer_def) {
      if (!is.null(layer_def$color_scale)) return(layer_def) # don't modify extant scale

      # flatten data into a list of data.frames for all possible layers across
      # this swaps the nesting so that we have [layers][slices]
      all_data <- lapply(seq_len(private$pvt_nslices), function(i) {
        c(private$pvt_slices$slice_data[[i]], private$pvt_slices$contrast_data[[i]])
      })
      img_data <- purrr::transpose(all_data)[[layer_def$name]] %>% bind_rows()

      message(glue("For layer {layer_def$name}, no color_scale specified. We will pick a default."))
      # detect appropriate default scale
      if (layer_def$name == "underlay") {
        layer_def$color_scale <- scale_fill_gradient(low="grey8", high="grey92")
        layer_def$show_legend <- FALSE # default to hiding underlay scale
      } else {
        has_pos <- any(img_data$value > 0, na.rm=TRUE)
        has_neg <- any(img_data$value < 0, na.rm=TRUE)
        if (has_pos && has_neg) {
          layer_def$color_scale <- scale_fill_distiller(palette="RdBu") # red-blue diverging
        } else if (has_neg) {
          layer_def$color_scale <- scale_fill_distiller(palette="Blues", direction = 1)
        } else if (has_pos) {
          layer_def$color_scale <- scale_fill_distiller(palette="Reds")
        } else {
          stop("Cannot find positive or negative values") # TODO: support discrete/character labels
        }
      }

      return(layer_def) # modified with default scale
    }
  ),
  active = list(
    #' @field layers a list of ggbrain_layer objects for this plot. Note that in assignment, the
    #'   input can be a list of ggbrain_layer objects, or a list of lists where each inner element
    #'   specifies the settings for that layer. Example: `list(list(name='hello', color_scale=scale_fill_distiller())`
    layers = function(value) {
      if (missing(value)) {
        private$pvt_layers
      } else {
        if (inherits(value, "ggbrain_layer")) {
          value <- list(value) # wrap as single element list
        }

        checkmate::assert_list(value)
        l_gg <- sapply(value, function(x) inherits(x, "ggbrain_layer"))
        l_li <- sapply(value, function(x) inherits(x, "list"))
        l_names <- sapply(value, "[[", "name")
        if (any(dupes <- duplicated(l_names))) {
          stop(glue::glue("Layer names cannot be duplicates. Problem with: {paste(l_names[dupes], collapse=', ')}"))
        }

        if (all(l_gg)) {
          # the input is a list of ggbrain_layer objects, which can be assigned directly
          private$pvt_layers <- value
        } else if (all(l_li)) {
          # the input is a list of lists
          # use ggbrain_layer constructor to create layers for each element
          private$pvt_layers <- do.call(ggbrain_layer$new, value)
        } else {
          stop("Cannot determine how to assign layers based on input.")
        }
      }
    }
  ),
  public=list(
    #' @description instantiate a new instance of a ggbrain_plot object
    #' @param slice_data a ggbrain_slices object generated by ggbrain_images$get_slices()
    initialize=function(slice_data = NULL) {
      checkmate::assert_class(slice_data, "ggbrain_slices")
      private$pvt_slices <- slice_data
      private$pvt_nslices <- length(slice_data$slice_index)
    },

    add_layers = function(layers = NULL) {
      if (!is.null(layers)) {
        checkmate::assert_list(layers)
        stopifnot(all(sapply(layers, function(x) "name" %in% names(x))))
        private$pvt_layers <- c(private$pvt_layers, layers) # append in order
      }
      return(self)
    },

    reset_layers = function() {
      private$pvt_layers <- NULL
    },

    #' @description generate the plot
    #' @param layers a list of layers to be displayed on each panel, the order of which yields the
    #'   bottom-to-to drawing order within ggplot2. Each element of \code{layers} should be a list
    #'   that follows the approximate structure of the ggbrain_layer class, minimally including
    #'   the layer \code{name}, which is used to lookup data of images or contrasts within the
    #'   slice_data object. If NULL, all layers in the slices object will be plotted. If only
    #'   a character string is passed, then those layers will be plotted with default scales.
    #' @param slice_indices An optional subset of slice indices to display from the stored slice data
    #' @details In addition to \code{name}, the elements of a layer can include
    #'   \code{color_scale} a ggplot2 scale object for coloring the layer. Should be a scale_fill_* object.
    #'   \code{limits} the numeric limits to use for the color scale of this layer
    #'   \code{breaks} the scale breaks to use for the color scale of this layer
    #'   \code{show_legend} if FALSE, the color scale will not appear in the legend
    generate_plot = function(layers=NULL, slice_indices=NULL) {
      possible_layer_names <- private$pvt_slices$get_image_names()
      if (is.null(layers)) {
        if (!is.null(private$pvt_layers)) {
          layers <- private$pvt_layers
        } else {
          message("No layers specified, so we will plot: ", paste(possible_layer_names, collapse = ", "))
          layers <- lapply(possible_layer_names, function(ll) list(name = ll))
        }
      } else if (is.character(layers)) {
        checkmate::assert_subset(layers, possible_layer_names)
        layers <- lapply(layers, function(ll) list(name=ll))
      }

      # each slice forms a ggbrain_panel
      slice_df <- private$pvt_slices$as_tibble()

      checkmate::assert_list(layers)

      # validate and touch up layer specification
      layers <- lapply(layers, function(l_i) {
        if (is.null(l_i$name)) {
          print(l_i)
          stop("This layer does not contain the required name element!")
        } else {
          checkmate::assert_string(l_i$name)
          stopifnot(l_i$name %in% possible_layer_names)
        }

        if (!is.null(l_i$color_scale)) {
          checkmate::assert_class("Scale", l_i$color_scale)
          stopifnot(l_i$color_scale$aesthetics == "fill")
        } else {
          l_i <- private$set_default_scale(l_i)
        }

        return(l_i)
      })

      all_layer_names <- sapply(layers, "[[", "name")

      if (!is.null(slice_indices)) {
        slice_df <- slice_df %>% filter(slice_index %in% !!slice_indices)
      }


      private$pvt_ggbrain_panels <- lapply(seq_len(nrow(slice_df)), function(i) {
        comb_data <- c(slice_df$slice_data[[i]], slice_df$contrast_data[[i]])
        comb_data <- comb_data[all_layer_names] # subset to only relevant data

        # list of layers
        slc_layers <- lapply(seq_along(layers), function(j) {
          l_obj <- layers[[j]]$clone(deep = TRUE)
          l_obj$data <- comb_data[[j]] # add slice-specific data to this this layer
          return(l_obj)
        })

        ggbrain_panel$new(
          layers = slc_layers,
          title = "Testing",
          bg_color = "black",
          text_color = "white",
          draw_border = FALSE,
          xlab = "X lab",
          ylab = "Y lab"
        )
      })

      return(self)
    },
    #' @description return a plot of all panels as a patchwork object
    plot = function() {
      # extract ggplot objects from panels and plot with patchwork wrap_plots
      wrap_plots(lapply(private$pvt_ggbrain_panels, function(x) x$gg))
    }
    # generate_panel = function(r) {
    #   
    # }
  )
)

#' S3 method to allow for plot() syntax with ggbrain_panel objects
#' @export
plot.ggbrain_plot <- function(object) {
  object$plot()
}

#' ggbrain_r6 <- R6::R6Class(
#'   classname = "ggbrain",
#'   private = list(
#'     layer_imgs = list(), # keep original data?
#'     pvt_panels = list(),
#'     composite_plot = NULL,
#'     set_panels = function(panels) {
#'       if (checkmate::assert_class(panels, "gg")) {
#' 
#'       }
#'       checkmate::assert_list(panels)
#'       sapply(panels, function(x) { checkmate::assert_class(x, "ggbrain_panel") })
#'       private$pvt_panels <- panels
#'     }
#'   ),
#'   active = list(
#'     #' @field panels The ggplot panels
#'     panels = function(val) {
#'       if (missing(val)) {
#'         return(private$pvt_panels)
#'       } else {
#'         private$set_panels(val)
#'       }
#'     }
#'   ),
#'   public = list(
#'     #' @description generate empty ggbrain object
#'     initialize = function(panels = NULL) {
#'       if (is.null(panels)) {
#'         stop("Cannot create a ggbrain object without panels!")
#'       } else {
#'         self$set_panels(panels)
#'       }
#'     },
#'     
#'     #' @description plot the composite plot
#'     plot = function() {
#'       plot(private$composite_plot)
#'     },
#'     
#'     #' @description return the composite plot
#'     get_composite_plot = function() {
#'       private$composite_plot
#'     },
#' 
#'     #' @description future idea? -- multiple views based on cached data
#'     create_view = function(slices) {
#'       private$views <- c(private$views, "VIEW HERE")
#'     }
#'   )
#' )
#' 
#' # allow for gg + theme() type stuff at panel level
#' `+.ggbrain` <- function(gg, args) {
#'   gg_new <- gg$clone(deep=TRUE) # need a new object to modify the panels in memory (not by reference)
#'   gg_new$panels <- lapply(gg_new$get_panels(), function(gg) { gg + args }) # add to each panel
#'   return(gg_new)
#' }
#' 
#' # allow for gg %+% theme() stuff at composite level
#' # this does not create a new ggbrain object... just adds to the composite plot.
#' `%+%.ggbrain` <- function(gg, args) {
#'   # gg_new <- gg$clone(deep=TRUE) # need a new object to modify the panels in memory (not by reference)
#'   gg$get_composite_plot() + args
#'   #return(gg_new)
#' }
# 
# plot.ggbrain <- function(obj) {
#   obj$plot()
# }
# 

