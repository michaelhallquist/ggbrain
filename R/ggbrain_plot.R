#' An R6 class for constructing a ggbrain plot from a ggbrain_slices object
#' @importFrom ggplot2 scale_fill_distiller
#' @export
ggbrain_plot <- R6::R6Class(
  classname="ggbrain_plot",
  private = list(
    pvt_slices = NULL,
    pvt_ggbrain_panels = NULL,
    pvt_nslices = NULL,
    set_default_scale = function(layer_def) {
      if (!is.null(layer_def$layer_scale)) { return(layer_def) } # don't modify extant scale
      
      # flatten data into a list of data.frames for all possible layers across
      # this swaps the nesting so that we have [layers][slices]
      all_data <- lapply(seq_len(private$pvt_nslices), function(i) {
        c(private$pvt_slices$slice_data[[i]], private$pvt_slices$contrast_data[[i]])
      })
      img_data <- purrr::transpose(all_data)[[layer_def$name]] %>% bind_rows()
      
      message(glue("For layer {layer_def$name}, no layer_scale specified. We will pick a default."))
      # detect appropriate default scale
      if (layer_def$name == "underlay") {
        layer_def$layer_scale <- scale_fill_gradient(low="grey8", high="grey92")
        layer_def$show_scale <- FALSE # default to hiding underlay scale
      } else {
        has_pos <- any(img_data$value > 0, na.rm=TRUE)
        has_neg <- any(img_data$value < 0, na.rm=TRUE)
        if (has_pos && has_neg) {
          layer_def$layer_scale <- scale_fill_distiller(palette="RdBu") # red-blue diverging
        } else if (has_neg) {
          layer_def$layer_scale <- scale_fill_distiller(palette="Blues", direction = 1)
        } else if (has_pos) {
          layer_def$layer_scale <- scale_fill_distiller(palette="Reds")
        } else {
          stop("Cannot find positive or negative values") # TODO: support discrete/character labels
        }
      }
      
      return(layer_def) # modified with default scale
    }
  ),
  public=list(
    #' @description instantiate a new instance of a ggbrain_plot object
    #' @param slice_data a ggbrain_slices object generated by ggbrain_images$get_slices()
    #' @param contrasts a list or named character vector of contrasts to display
    initialize=function(slice_data, contrasts) {
      checkmate::assert_class(slice_data, "ggbrain_slices")
      private$pvt_slices <- slice_data
      private$pvt_nslices <- length(slice_data$slice_index)
    },
    
    #' @description generate the plot
    #' @param layers a list of layers to be displayed on each panel, the order of which yields the
    #'   bottom-to-to drawing order within ggplot2. Each element of \code{layers} should be a list
    #'   that follows the approximate structure of the ggbrain_layer class, minimally including
    #'   the layer \code{name}, which is used to lookup data of images or contrasts within the
    #'   slice_data object. If NULL, all layers in the slices object will be plotted. If only
    #'   a character string is passed, then those layers will be plotted with default scales.
    #' @param slice_indices An optional subset of slice indices to display from the stored slice data
    #' @details In addition to \code{name}, the elements of a layer can include
    #'   \code{layer_scale} a ggplot2 scale object for coloring the layer. Should be a scale_fill_* object.
    #'   \code{limits} the numeric limits to use for the color scale of this layer
    #'   \code{breaks} the scale breaks to use for the color scale of this layer
    #'   \code{show_scale} if FALSE, the color scale will not appear in the legend
    generate_plot = function(layers=NULL, slice_indices=NULL) {
      possible_layer_names <- private$pvt_slices$get_image_names()
      if (is.null(layers)) {
        message("No layers specified, so we will plot: ", paste(possible_layer_names, collapse=", "))
        layers <- lapply(possible_layer_names, function(ll) list(name=ll))
      } else if (is.character(layers)) {
        checkmate::assert_subset(layers, possible_layer_names)
        layers <- lapply(layers, function(ll) list(name=ll))
      }
      
      # each slice forms a ggbrain_panel
      slice_df <- private$pvt_slices$as_tibble()
      
      checkmate::assert_list(layers)
      
      # validate and touch up layer specification
      layers <- lapply(layers, function(l_i) {
        if (is.null(l_i$name)) {
          print(l_i)
          stop("This layer does not contain the required name element!")
        } else {
          checkmate::assert_string(l_i$name)
          stopifnot(l_i$name %in% possible_layer_names)
        }
        
        if (!is.null(l_i$layer_scale)) {
          checkmate::assert_class("Scale", l_i$layer_scale)
          stopifnot(l_i$layer_scale$aesthetics == "fill")
        } else {
          l_i <- private$set_default_scale(l_i)
        }
        
        # make sure that NAs are always drawn as transparent
        if (l_i$layer_scale$na.value != "transparent") { 
          l_i$layer_scale$na.value <- "transparent"
        }
        
        return(l_i)
      })
      
      all_layer_names <- sapply(layers, "[[", "name")
      
      if (!is.null(slice_indices)) {
        slice_df <- slice_df %>% filter(slice_index %in% !!slice_indices)
      }
      
      private$pvt_ggbrain_panels <- lapply(seq_len(nrow(slice_df)), function(i) {
        comb_data <- c(slice_df$slice_data[[i]], slice_df$contrast_data[[i]])
        comb_data <- comb_data[all_layer_names] # subset to only relevant data
        
        # list of layers
        slc_layers <- lapply(seq_along(layers), function(j) {
          l_call <- c(layers[[j]], list(data=comb_data[[j]]))
          
          do.call(ggbrain_layer$new, l_call)
        })
        
        ggbrain_panel$new(
          layers = slc_layers,
          title = "Testing",
          bg_color = "black",
          text_color = "white",
          draw_border = FALSE,
          xlab = "X lab",
          ylab = "Y lab"
        )
      })
      
      return(self)
    },
    #' @description return a plot of all panels as a patchwork object
    plot = function() {
      # extract ggplot objects from panels and plot with patchwork wrap_plots
      wrap_plots(lapply(private$pvt_ggbrain_panels, function(x) x$gg))
    }
    # generate_panel = function(r) {
    #   
    # }
  )
)

#' S3 method to allow for plot() syntax with ggbrain_panel objects
#' @export
plot.ggbrain_plot <- function(object) {
  object$plot()
}

#' ggbrain_r6 <- R6::R6Class(
#'   classname = "ggbrain",
#'   private = list(
#'     layer_imgs = list(), # keep original data?
#'     pvt_panels = list(),
#'     composite_plot = NULL,
#'     set_panels = function(panels) {
#'       if (checkmate::assert_class(panels, "gg")) {
#' 
#'       }
#'       checkmate::assert_list(panels)
#'       sapply(panels, function(x) { checkmate::assert_class(x, "ggbrain_panel") })
#'       private$pvt_panels <- panels
#'     }
#'   ),
#'   active = list(
#'     #' @field panels The ggplot panels
#'     panels = function(val) {
#'       if (missing(val)) {
#'         return(private$pvt_panels)
#'       } else {
#'         private$set_panels(val)
#'       }
#'     }
#'   ),
#'   public = list(
#'     #' @description generate empty ggbrain object
#'     initialize = function(panels = NULL) {
#'       if (is.null(panels)) {
#'         stop("Cannot create a ggbrain object without panels!")
#'       } else {
#'         self$set_panels(panels)
#'       }
#'     },
#'     
#'     #' @description plot the composite plot
#'     plot = function() {
#'       plot(private$composite_plot)
#'     },
#'     
#'     #' @description return the composite plot
#'     get_composite_plot = function() {
#'       private$composite_plot
#'     },
#' 
#'     #' @description future idea? -- multiple views based on cached data
#'     create_view = function(slices) {
#'       private$views <- c(private$views, "VIEW HERE")
#'     }
#'   )
#' )
#' 
#' # allow for gg + theme() type stuff at panel level
#' `+.ggbrain` <- function(gg, args) {
#'   gg_new <- gg$clone(deep=TRUE) # need a new object to modify the panels in memory (not by reference)
#'   gg_new$panels <- lapply(gg_new$get_panels(), function(gg) { gg + args }) # add to each panel
#'   return(gg_new)
#' }
#' 
#' # allow for gg %+% theme() stuff at composite level
#' # this does not create a new ggbrain object... just adds to the composite plot.
#' `%+%.ggbrain` <- function(gg, args) {
#'   # gg_new <- gg$clone(deep=TRUE) # need a new object to modify the panels in memory (not by reference)
#'   gg$get_composite_plot() + args
#'   #return(gg_new)
#' }
# 
# plot.ggbrain <- function(obj) {
#   obj$plot()
# }
# 

