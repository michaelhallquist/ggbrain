#' R6 class for managing slice data for ggbrain plots
#' @importFrom dplyr bind_rows
#' @importFrom tidyr pivot_wider
#' @importFrom tibble tibble
#' @author Michael Hallquist
#' @keywords internal
ggbrain_slices <- R6::R6Class(
  classname="ggbrain_slices",
  private = list(
    pvt_slice_index=NULL,
    pvt_coord_input=NULL,
    pvt_coord_label=NULL,
    pvt_plane=NULL,
    pvt_slice_number=NULL,
    pvt_slice_data=list(),
    pvt_slice_matrix=list(),
    pvt_slice_labels=list(),
    pvt_contrast_data=list()
  ),
  
  # these active bindings create read-only access to class properties
  active = list(
    #' @field slice_index read-only access to the slice_index containing the slice numbers
    slice_index = function(value) {
      if (missing(value)) private$pvt_slice_index
      else stop("Cannot assign slice_index")
    },
    #' @field coord_input the input string used to lookup the slices
    coord_input = function(value) {
      if (missing(value)) private$pvt_coord_input
      else stop("Cannot assign coord_input")
    },
    #' @field coord_label the calculated x, y, or z coordinate of the relevant slice
    coord_label = function(value) {
      if (missing(value)) private$pvt_coord_label
      else stop("Cannot assign coord_label")
    },
    #' @field slice_number the slice number along the relevant axis of the 3D image matrix
    slice_number = function(value) {
      if (missing(value)) private$pvt_slice_number
      else stop("Cannot assign slice_number")
    },
    #' @field slice_data a nested list of data.frames where each element contains all data relevant to
    #'   that slice and the list elements within are each a given image
    slice_data = function(value) {
      if (missing(value)) private$pvt_slice_data
      else stop("Cannot assign slice_data")
    },
    #' @field slice_matrix the slice data in matrix form
    slice_matrix = function(value) {
      if (missing(value)) private$pvt_slice_matrix
      else stop("Cannot assign slice_matrix")
    },
    slice_labels = function(value) {
      if (missing(value)) private$pvt_slice_labels
      else stop("Cannot assign slice_labels")
    },
    contrast_data = function(value) {
      if (missing(value)) private$pvt_contrast_data
      else stop("Cannot assign contrast_data")
    }
  ),
  public = list(
    #' @description create a ggbrain_slices object based
    #' @param slice_df a data.frame generated by ggbrain_images$get_slices()
    #' @details If this becomes a user-facing/exported class, we may want a more friendly constructor
    initialize = function(slice_df = NULL) {
      checkmate::assert_data_frame(slice_df)

      # empty lists for populating unused fields -- match length of slice_df for consistency
      empty_list <- lapply(seq_len(nrow(slice_df)), function(i) list())

      df_names <- names(slice_df)
      private$pvt_coord_input <- ifelse("coord_input" %in% df_names, slice_df$coord_input, empty_list)
      private$pvt_coord_label <- ifelse("coord_label" %in% df_names, slice_df$coord_label, empty_list)
      private$pvt_plane <- ifelse("plane" %in% df_names, slice_df$plane, empty_list)
      private$pvt_slice_index <- ifelse("slice_index" %in% df_names, slice_df$slice_index, empty_list)
      private$pvt_slice_number <- ifelse("slice_number" %in% df_names, slice_df$slice_number, empty_list)
      private$pvt_slice_data <- ifelse("slice_data" %in% df_names, slice_df$slice_data, empty_list)
      private$pvt_slice_labels <- ifelse("slice_labels" %in% df_names, slice_df$slice_labels, empty_list)
      private$pvt_slice_matrix <- ifelse("slice_matrix" %in% df_names, slice_df$slice_matrix, empty_list)
      private$pvt_contrast_data <- ifelse("contrast_data" %in% df_names, slice_df$contrast_data, empty_list)
    },
    
    #' @description computes contrasts of the sliced image data
    #' @param contrast_list a named list or character vector containing contrasts to be computed.
    #'   The names of the list form the contrast names, while the values should be character strings
    #'   that use standard R syntax for logical tests, subsetting, and arithmetic
    #' @examples 
    #' \dontrun{
    #'   slc <- ggbrain_slices$new(slice_df=my_data)
    #'   slc$add_contrasts(list(pos_vals="overlay[overlay> 0]"))
    #' }
    add_contrasts = function(contrast_list=NULL) {
      if (checkmate::test_class(contrast_list, "character")) {
        contrast_list = as.list(contrast_list) # tolerate named character vector input
      }
      
      checkmate::assert_list(contrast_list, names = "unique")
      if (length(private$pvt_slice_data) == 0L) {
        stop("Cannot use $add_contrasts() if there are no slice_data in the object")
      }
      
      # convert slice data to wide format to allow contrasts to be parsed
      wide <- lapply(private$pvt_slice_data, function(slc_xx) {
        ss <- slc_xx %>% dplyr::bind_rows() %>% 
          tidyr::pivot_wider(id_cols = c(dim1, dim2), 
                             names_from = "image", 
                             names_glue = "{image}_{.value}",
                             values_from=c(value, label))
        names(ss) <- sub("_value$", "", names(ss)) # remove _value suffix to make evaluation of contrasts easier
        return(ss)
      })

      if (any(names(contrast_list) %in% names(private$pvt_contrast_data))) {
        overlap <- intersect(names(contrast_list), names(private$pvt_contrast_data))
        warning("Existing contrast data will be replaced for the following contrasts: ", paste(overlap, collapse=", "))
      }
      
      private$pvt_contrast_data <- lapply(seq_along(wide), function(ww) {
        c_data <- lapply(seq_along(contrast_list), function(cc) {
          contrast_parser(contrast_list[[cc]], data = wide[[ww]]) %>%
            mutate(image = names(contrast_list)[cc]) # tag contrasts with a label column
        }) %>% setNames(names(contrast_list))
        
        if (length(private$pvt_contrast_data) > 0L) {
          e_data <- private$pvt_contrast_data[[ww]]
        } else {
          e_data <- list()
        }
        e_data[names(c_data)] <- c_data # update relevant elements of extant data
        return(e_data)
      })
      
    },
    
    #' @description convert the slices object into a data.frame with list-columns for slice data elements
    as_tibble = function() {
      tibble::tibble(
        coord_input=private$pvt_coord_input,
        coord_label=private$pvt_coord_label,
        plane=private$pvt_plane,
        slice_index=private$pvt_slice_index,
        slice_number=private$pvt_plane,
        slice_data=private$pvt_slice_data,
        slice_labels=private$pvt_slice_labels,
        slice_matrix=private$pvt_slice_matrix,
        contrast_data=private$pvt_contrast_data
      )
    },
    
    #' @description returns a vector of the names of all image and contrast data available in this
    #'   ggbrain_slices object.
    get_image_names = function() {
      if (length(private$pvt_contrast_data) > 0L) {
        nmc <- names(private$pvt_contrast_data[[1]]) # first slice should be representative
      } else {
        nmc <- NULL
      }
      
      if (length(private$pvt_slice_data) > 0L) {
        nms <- names(private$pvt_slice_data[[1]]) # first slice should be representative
      } else {
        nms <- NULL
      }
      
      return(c(nms, nmc))
    }
  )
)
